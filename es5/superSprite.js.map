{"version":3,"sources":["../es6/superSprite.js"],"names":[],"mappings":"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","file":"superSprite.js","sourcesContent":["let Container = PIXI.Container,\n  TextureCache = PIXI.utils.TextureCache,\n  Texture = PIXI.Texture,\n  Rectangle = PIXI.Rectangle,\n  MovieClip = PIXI.extras.MovieClip,\n  TilingSprite = PIXI.extras.TilingSprite;\n\n\nfunction  superSprite(source, x = 0, y = 0, tiling = false, width, height) {\n\n  let o, texture;\n  \n  //Create a sprite if the `source` is a string \n  if (typeof source === \"string\") {\n\n    //Access the texture in the cache if it's there\n    if (TextureCache[source]) {\n      texture = TextureCache[source];\n    }\n\n    //If it's not is the cache, load it from the source file\n    else {\n      texture = Texture.fromImage(source);\n    }\n\n    //If the texture was created, make the o\n    if(texture) {\n\n      //If `tiling` is `false`, make a regular `Sprite`\n      if(!tiling) {\n        o = new Sprite(texture);\n      } \n\n      //If `tiling` is `true` make a `TilingSprite`\n      else {\n        o = new TilingSprite(texture, width, height);\n      }\n    }\n    //But if the source still can't be found, alert the user\n    else {\n      console.log(`${source} cannot be found`);\n    }\n  } \n\n  //Create a o if the `source` is a texture\n  else if (source instanceof Texture) {\n    if (!tiling) {\n      o = new Sprite(source);\n    }else{\n      o = new TilingSprite(source, width, height);\n    }\n  }\n\n  //Create a `MovieClip` o if the `source` is an array\n  else if (source instanceof Array) {\n\n    //Is it an array of frame ids or textures?\n    if(typeof source[0] === \"string\") {\n\n      //They're strings, but are they pre-existing texture or\n      //paths to image files?\n      //Check to see if the first element matches a texture in the\n      //cache\n      if(TextureCache[source[0]]){\n\n        //It does, so it's an array of frame ids\n        o = MovieClip.fromFrames(source);\n      }\n      else {\n\n        //It's not already in the cache, so let's load it\n        o = MovieClip.fromImages(source);\n      }\n    }\n\n    //If the `source` isn't an array of strings, check whether\n    //it's an array of textures\n    else if (source[0] instanceof Texture) {\n\n      //Yes, it's an array of textures. \n      //Use them to make a MovieClip o \n      o = new MovieClip(source);\n    }\n  }\n\n  //If the sprite was successfully created, intialize it\n  if(o) {\n\n    //Position the sprite\n    o.x = x;\n    o.y = y;\n\n    //Set optional width and height\n    if (width) o.width = width;\n    if (height) o.height = height;\n\n    //If the sprite is a MovieClip, add a state player so that\n    //it's easier to control\n    if (o instanceof MovieClip) addStatePlayer(o);\n\n    //Add some extra properties to the sprite \n    //addProperties(o);\n\n    //Assign the sprite\n    return o;\n  }    \n}\n\nfunction addStatePlayer(sprite) {\n\n  let frameCounter = 0,\n      numberOfFrames = 0,\n      startFrame = 0,\n      endFrame = 0,\n      timerInterval = undefined;\n\n  //The `show` function (to display static states)\n  function show(frameNumber) {\n    \n    //Reset any possible previous animations\n    reset();\n    \n    //Find the new state on the sprite\n    sprite.gotoAndStop(frameNumber);\n  }\n\n  //The `play` function plays all the sprite's frames\n  function playAllFrames() {\n    playSequence([0, sprite.totalFrames - 1]);\n  }\n\n  //The `stop` function stops the animation at the current frame\n  function stopAnimation() {\n    reset();\n    sprite.gotoAndStop(sprite.currentFrame);\n  }\n\n  //The `playSequence` function, to play a sequence of frames\n  function playSequence(sequenceArray) {\n\n    //Reset any possible previous animations\n    reset();\n\n    //Figure out how many frames there are in the range\n    startFrame = sequenceArray[0];\n    endFrame = sequenceArray[1];\n    numberOfFrames = endFrame - startFrame;\n\n    //Compensate for two edge cases:\n    //1. If the `startFrame` happens to be `0`\n    /*\n    if (startFrame === 0) {\n      numberOfFrames += 1;\n      frameCounter += 1;\n    }\n    */\n\n    //2. If only a two-frame sequence was provided\n    /*\n    if(numberOfFrames === 1) {\n      numberOfFrames = 2;\n      frameCounter += 1;\n    }  \n    */\n\n    //Calculate the frame rate. Set the default fps to 12\n    if (!sprite.fps) sprite.fps = 12;\n    let frameRate = 1000 / sprite.fps;\n\n    //Set the sprite to the starting frame\n    sprite.gotoAndStop(startFrame);\n\n    //Set the `frameCounter` to the first frame \n    frameCounter = 1;\n\n    //If the state isn't already `playing`, start it\n    if(!sprite.isPlaying) {\n      timerInterval = setInterval(advanceFrame.bind(this), frameRate);\n      sprite.isPlaying = true;\n    } \n  }\n\n  //`advanceFrame` is called by `setInterval` to display the next frame \n  //in the sequence based on the `frameRate`. When the frame sequence \n  //reaches the end, it will either stop or loop\n  function advanceFrame() {\n\n    //Advance the frame if `frameCounter` is less than \n    //the state's total frames\n    if (frameCounter < numberOfFrames + 1) {\n\n      //Advance the frame\n      sprite.gotoAndStop(sprite.currentFrame + 1);\n    \n      //Update the frame counter\n      frameCounter += 1;\n\n      //If we've reached the last frame and `loop`\n      //is `true`, then start from the first frame again\n     } else {\n        if (sprite.loop) {\n        sprite.gotoAndStop(startFrame);\n        frameCounter = 1;\n      } \n    }\n  }\n\n  function reset() {\n\n    //Reset `sprite.playing` to `false`, set the `frameCounter` to 0, //and clear the `timerInterval`\n    if (timerInterval !== undefined && sprite.isPlaying === true) {\n      sprite.isPlaying = false;\n      frameCounter = 0;\n      startFrame = 0;\n      endFrame = 0;\n      numberOfFrames = 0;\n      clearInterval(timerInterval);\n    } \n  }\n\n  //Add the `show`, `play`, `stop`, and `playSequence` methods to the sprite\n  sprite.show = show;\n  sprite.playAllFrames = playAllFrames;\n  sprite.stopAnimation = stopAnimation;\n  sprite.playSequence = playSequence;\n}\n\nfunction filmstrip(\n  texture, \n  frameWidth, \n  frameHeight, \n  spacing = 0 \n){\n\n  //An array to store the x/y positions of the frames\n  let positions = []; \n\n  //Find the width and height of the texture\n  let textureWidth = TextureCache[texture].width, \n      textureHeight = TextureCache[texture].height;\n\n  //Find out how many columns and rows there are\n  let columns = textureWidth / frameWidth,\n      rows = textureHeight / frameHeight;\n\n  //Find the total number of frames\n  let numberOfFrames = columns * rows;    \n\n  for(let i = 0; i < numberOfFrames; i++) {\n\n    //Find the correct row and column for each frame\n    //and figure out its x and y position\n    let x = (i % columns) * frameWidth,\n        y = Math.floor(i / columns) * frameHeight;\n\n    //Compensate for any optional spacing (padding) around the tiles if\n    //there is any. This bit of code accumlates the spacing offsets from the \n    //left side of the tileset and adds them to the current tile's position \n    if (spacing > 0) {\n      x += spacing + (spacing * i % columns); \n      y += spacing + (spacing * Math.floor(i / columns));\n    }\n\n    //Add the x and y value of each frame to the `positions` array\n    positions.push([x, y]);\n  }\n  console.log(positions)\n\n  //Return the frames\n  return frames(texture, positions, frameWidth, frameHeight);\n};\n\n//Make a texture from a frame in another texture or image\nfunction frame(source, x, y, width, height) {\n\n  let texture, imageFrame;\n\n  //If the source is a string, it's either a texture in the\n  //cache or an image file\n  if (typeof source === \"string\") {\n    if (TextureCache[source]) {\n      texture = new Texture(TextureCache[source]);\n    } \n  }\n\n  //If the `source` is a texture,  use it\n  else if (source instanceof Texture) {\n    texture = new Texture(source);\n  }\n  if(!texture) {\n    console.log(`Please load the ${source} texture into the cache.`);\n  } else {\n\n    //Make a rectangle the size of the sub-image\n    imageFrame = new Rectangle(x, y, width, height);\n    texture.frame = imageFrame;\n    return texture;\n  }\n}\n\n//Make an array of textures from a 2D array of frame x and y coordinates in\n//texture\nfunction frames(source, coordinates, frameWidth, frameHeight) {\n\n  let baseTexture, textures;\n\n  //If the source is a string, it's either a texture in the\n  //cache or an image file\n  if (typeof source === \"string\") {\n    if (TextureCache[source]) {\n      baseTexture = new Texture(TextureCache[source]);\n    } \n  }\n  //If the `source` is a texture,  use it\n  else if (source instanceof Texture) {\n    baseTexture = new Texture(source);\n  }\n  if(!baseTexture) {\n    console.log(`Please load the ${source} texture into the cache.`);\n  } else {\n    let textures = coordinates.map((position) => {\n      let x = position[0],\n          y = position[1];\n      let imageFrame = new Rectangle(x, y, frameWidth, frameHeight);\n      let frameTexture = new Texture(baseTexture);\n      frameTexture.frame = imageFrame;\n      return frameTexture \n    });\n    return textures;\n  }\n}\n\nfunction frameSeries(startNumber = 0, endNumber = 1, baseName = \"\", extension = \"\") {\n\n  //Create an array to store the frame names\n  let frames = [];\n\n  for (let i = startNumber; i < endNumber + 1; i++) {\n    let frame = baseName + i + extension;\n    frames.push(frame);\n  }\n  \n  return frames;\n}\n"]}